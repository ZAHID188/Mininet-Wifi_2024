<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network Packet Monitor</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 100%;
            margin: 0 auto;
            overflow-x: auto;
        }
        #status {
            padding: 10px;
            margin-bottom: 20px;
            background-color: #e3f2fd;
            border-radius: 4px;
        }
        .packet-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
            background-color: white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.12);
            font-size: 14px;
        }
        .packet-table th, .packet-table td {
            padding: 8px;
            text-align: left;
            border: 1px solid #ddd;
        }
        .packet-table th {
            background-color: #2196F3;
            color: white;
        }
        .packet-table tr:nth-child(even) {
            background-color: #f8f9fa;
        }
        .packet-container {
            margin-bottom: 30px;
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .packet-timestamp {
            color: #666;
            margin-bottom: 10px;
            font-size: 0.9em;
        }
        #messages {
            height: 800px;
            overflow: auto;
            padding: 10px;
        }
        .protocol-cell {
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Network Packet Monitor</h1>
        <div id="status">Connecting...</div>
        <div id="messages"></div>
    </div>

<script>
    const socket = new WebSocket('ws://127.0.0.1:8080/simpleswitch/ws');

    function createPacketTable(data) {
        const container = document.createElement('div');
        container.className = 'packet-container';

        const timestamp = document.createElement('div');
        timestamp.className = 'packet-timestamp';
        timestamp.textContent = new Date().toLocaleTimeString();
        container.appendChild(timestamp);

        const table = document.createElement('table');
        table.className = 'packet-table';

        // Add header
        const header = table.createTHead();
        const headerRow = header.insertRow();
        ['Protocol Layer', 'Field', 'Value'].forEach(text => {
            const th = document.createElement('th');
            th.textContent = text;
            headerRow.appendChild(th);
        });

        const tbody = table.createTBody();

        // Add Ethernet layer
        addLayerRows(tbody, 'Ethernet', [
            ['Destination MAC', data.ethernet?.dst || ''],
            ['Source MAC', data.ethernet?.src || ''],
            ['EtherType', data.ethernet?.ethertype || '']
        ]);

        // Add IPv4/IPv6 layer
        if (data.ipv4) {
            addLayerRows(tbody, 'IPv4', [
                ['Destination Address', data.ipv4.dst || ''],
                ['Source Address', data.ipv4.src || ''],
                ['TTL', data.ipv4.ttl || ''],
                ['Protocol', data.ipv4.proto || '']
            ]);
        } else if (data.ipv6) {
            addLayerRows(tbody, 'IPv6', [
                ['Destination Address', data.ipv6.dst || ''],
                ['Source Address', data.ipv6.src || ''],
                ['Hop Limit', data.ipv6.hop_limit || ''],
                ['Next Header', data.ipv6.nxt || '']
            ]);
        }

        // Add ICMPv6 layer if present
        if (data.icmpv6) {
            addLayerRows(tbody, 'ICMPv6', [
                ['Type', data.icmpv6.type || ''],
                ['Checksum', data.icmpv6.checksum || ''],
                ['Source Link-Layer Address', data.icmpv6.src_ll_addr || '']
            ]);
        }

        container.appendChild(table);
        return container;
    }

    function addLayerRows(tbody, protocolLayer, fields) {
        fields.forEach((field, index) => {
            const row = tbody.insertRow();
            if (index === 0) {
                const protocolCell = row.insertCell();
                protocolCell.textContent = protocolLayer;
                protocolCell.rowSpan = fields.length;
                protocolCell.className = 'protocol-cell';
            }
            const fieldCell = row.insertCell();
            const valueCell = row.insertCell();
            fieldCell.textContent = field[0];
            valueCell.textContent = field[1];
        });
    }

    socket.addEventListener('open', () => {
        document.getElementById('status').textContent = 'Connected to server';
    });

    socket.addEventListener('message', (event) => {
        try {
            const data = JSON.parse(event.data);
            const messages = document.getElementById('messages');
            const packetTable = createPacketTable(data);
            
            if (messages.firstChild) {
                messages.insertBefore(packetTable, messages.firstChild);
            } else {
                messages.appendChild(packetTable);
            }

            // Keep only the last 50 packets
            while (messages.children.length > 50) {
                messages.removeChild(messages.lastChild);
            }
        } catch (e) {
            console.error('Error parsing packet data:', e);
        }
    });

    socket.addEventListener('close', () => {
        document.getElementById('status').textContent = 'Disconnected from server';
    });

    socket.addEventListener('error', (error) => {
        console.error('WebSocket error:', error);
        document.getElementById('status').textContent = 'Connection error';
    });
</script>

</body>
</html>